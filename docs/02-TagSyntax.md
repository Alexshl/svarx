### Используемые теги ###
#### Блок validate ####
Содержит описания правил валидации. Правила описываются тегами &lt;rule&gt;, группы правил, в т.ч. условная валидация — тегами &lt;block&gt;.
Каждый раз перед началом валидации выполняется препроцессинг полей на основе указанных в блоке &lt;preprocess&gt; правил.

Внутри одного svarx-файла можно хранить несколько блоков &lt;validate&gt;. В этом случае нужно каждому из них указывать уникальный идентификатор через атрибут **id**.
По умолчанию будет использован первый по порядку блок, но при инициализации jQuery-SVARX-плагина в опциях можно передать ключ **validateBlockId**, и в этом случае будет использован блок с соответствующим **id**.

#### Тег rule ####
Тег &lt;rule&gt; имеет две формы: краткую (для описания валидации с участием одного поля) и полную (для описания валидации с участием более одного поля, когда валидирующее правило проверяет несколько полей сразу).

##### Краткая форма тега rule #####
Имеет **обязательный** атрибут:

* **type** — имя (алиас) валидирующего правила.

**Опциональные** атрибуты, общие для всех тегов &lt;rule&gt;:

* **for** — имя поля формы, к которому применяется правило. Если этот атрибут не указан, то на вход валидирующему правилу придут все имеющиеся элементы формы.
* **item** — если в форме несколько элементов с одинаковым именем, то item позволяет указать номер элемента (нумерация с нуля).
* **onerror** — идентификатор ошибки, которая будет вызвана в случае нарушения правила. Может состоять из латинских букв, подчёркиваний и тире.
* **errtarget** — имя поля формы, на котором реально будет вызван обработчик SVARX-ошибки для данного правила. По умолчанию, это событие выполняется на поле, указанном внутри атрибута for, но данный атрибут позволяет переопределить это поведение. Этот атрибут используется для семантического соотнесения ошибки с другим элементом, нежели тот, на кототом определёно правило валидации.
* **errtargetitem** — аналог атрибута **item**, но относится к **errtarget**. Для случая, когда указан **errtarget** и в форме есть несколько элементов с подобным именем, использование **errtargetitem** позволяет указать номер элемента. Нумерация с нуля.
* **inverted="yes|no"** — логическое **not** для правила, меняющее результат проверки на противоположный

Прочие атрибуты тега &lt;rule&gt; зависят от указанного типа проверки.

##### Полная форма тега rule #####
Тег &lt;rule&gt; в полной форме является контейнером, у которого могут быть вложенные элементы.
Атрибуты **for**, **item**, **errtarget**, **errtargetitem** в полной форме записи не используются, вместо них в контейнер тега &lt;rule&gt; добавляются вложенные теги:

* &lt;el /&gt; — аналог атрибута **for** из краткой формы, используется для указания элемента, с которым связано правило
* &lt;errtarget /&gt; — аналог атрибута **errtarget**

Теги &lt;el&gt; и &lt;errtarget&gt; имеют атрибут **name** для указания имени элемента формы, и опциональный атрибут **item** (аналог атрибутов **item** и **errtargetitem** из краткой формы записи). Семантика остаётся та же самая, но для правил, проверяющих более одного поля (например, проверка равенства двух полей), можно перечислить все эти поля, чего нельзя сделать в краткой записи. Теоретически, можно всегда пользоваться полной формой, но результирующий XML получится более объёмным.
У тега &lt;errtarget&gt; можно использовать атрибут **alias**, который может принимать одно из двух значений: **form** и **children**.
В первом случае, ошибка возникает на самой форме (на DOM-элементе формы), а во втором — на всех элементах, соотнесённых с дочерними правилами &lt;rule&gt; текущего блока (и, таким образом, имеет смысл только на кумулятивных правилах).
При этом вложенные теги &lt;block&gt; игнорируются, однако переопределения errtarget у правил учитываются.
То есть, в приведённом ниже примере

```xml
<block onerror="epic_fail">
    <errtarget alias="children" />
    
    <rule for="login" type="email" />
    <rule for="password" type="regexp" match="[0-9a-z]+" flags="i" errtarget="password2" />

    <block onerror="login_fail">
        <rule for="login" type="regexp" partmatch="^[a-z]" />
        <rule for="login" type="regexp" partmatch="[a-z]$" />
    </block>
</block>
```
ошибка с идентификатором **epic_fail** будет проассоциирована с элементами формы **login** и **password2**.

Прочие атрибуты тега &lt;rule&gt; в полной форме, как и в краткой, зависят от указанного типа проверки.

По умолчанию все правила в блоке &lt;validate&gt; связаны логикой AND, т.е. форма считается безошибочной, если ни одно правило не вызвало ошибки.

Правила &lt;rule&gt; можно объединять в семантические блоки &lt;block&gt;. У &lt;block&gt; нет обязательных атрибутов, но есть опциональные:

* **logic="and|or|if"** — логика объединения вложенных правил <rule> (по умолчанию — and). Значение **if** имеет особую семантику, о ней ниже.
* **onerror**  — идентификатор ошибки, которая будет вызвана в случае, если проверка блока провалилась.
* **errtarget**, **errtargetitem** — см. выше. Этот атрибут особенно полезен именно для &lt;block&gt;, т.к. он семантически не привязан ни к одному полю формы, а это не всегда хорошо.
* **inverted="yes|no"**  — аналогично <rule>, но меняет логическое значение результата блока целиком 

У тега &lt;block&gt;, так же как и у тега &lt;rule&gt;, есть полная форма записи (выше описана именно краткая). Полная форма отличается тем, что запрещает использование атрибутов **errtarget** B **errtargetitem**, но разрешает использование вложенных тегов &lt;errtarget&gt;, аналогично полной форме записи тега &lt;rule&gt;.

Блоки можно неограниченно вкладывать друг в друга.

Блок с logic="if" ведёт себя особым образом: он эмулирует поведение стандартного "if..then..else". У такого блока должно быть не менее двух потомков (ими могут быть другие &lt;block&gt; или &lt;rule&gt;). Первый считается условием (аналог IF), второй блок (аналог THEN) вступает в силу (т.е. учитывается при валидации) только тогда, когда первый блок при проверке истинен. Опциональный третий блок (аналог ELSE) вступает в силу тогда, когда первый блок даёт при проверке ложный результат.

Пример:

```xml
<block logic="if">
    <!--  Если поле login не является адресом e-mail, то... -->
    <rule for="login" type="email" inverted="yes" />
    <!--  ...считать ошибкой, если оно начинается с цифры: -->
    <rule for="login" type="regexp" partmatch="^\d" inverted="yes" onerror="login_start_digit" />
</block>
```

Атрибуты onerror на первом элементе условного блока (аналоге IF) и на самом &lt;block logic=&quot;if&quot;&gt; ведут себя не так, как (вероятно) ожидает пользователь, поэтому на этих блоках указывать их не рекомендуется. Возможно, в будущем эта рекомендация станет правилом. Чтобы обработать результат проверки условного блока, используйте обработчики onerror на блоках THEN или ELSE.

#### Блок preprocess ####
В этом блоке перечисляются правила предварительной обработки значений полей. Каждое правило имеет синтаксис, аналогичный синтаксису тегов &lt;rule&gt;, но при этом не рассматриваются атрибуты **errtarget** и **errtargetitem**.


```xml
<rule
    for="имя поля"
    type="тип препроцессинга"
/>

```
Объединение правил в блоки не используется, но можно задавать несколько полей с использованием расширенного синтаксиса тега &lt;rule&gt; (см. соответствующий раздел).

Препроцессинг выполняется с соблюдением указанного порядка полей и обработок.
Неизвестные типы обработок игнорируются.

Препроцессинг **не выполняется**:

* **Для любых не-текстовых контролов** (т.е. чекбоксы, радиобаттоны, селекты не обрабатываются)
* Для полей типа "file" (попытка изменения значений на таких полях выдаёт security error)
* Для полей, отмеченных как readonly (спорное место, реализация может измениться)

Пример:

```xml
<preprocess>
    <rule for="iname" type="trim" />
    <rule for="bday" type="parseint" />
</preprocess>

```

Внутри одного svarx-файла можно хранить несколько блоков &lt;preprocess&gt;. В этом случае нужно каждому из них указывать уникальный идентификатор через атрибут **id**.
По умолчанию будет использован первый по порядку блок, но при инцииализации jQuery-SVARX-плагина в опциях можно передать ключ **preprocessBlockId**, и в этом случае будет использован блок с соответствующим **id**.
