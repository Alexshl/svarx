### Используемые теги ###
#### Блок validate ####
Содержит описания правил валидации. Правила описываются тегами &lt;rule&gt;, группы правил, в т.ч. условная валидация — тегами &lt;block&gt;.
Каждый раз перед началом валидации выполняется препроцессинг полей на основе указанных в блоке &lt;preprocess&gt; правил.

Внутри одного svarx-файла можно хранить несколько блоков &lt;validate&gt;. В этом случае нужно каждому из них указывать уникальный идентификатор через атрибут **id**.
По умолчанию будет использован первый по порядку блок, но при инцииализации jQuery-SVARX-плагина в опциях можно передать ключ **validateBlockId**, и в этом случае будет использован блок с соответствующим **id**.

#### Тег rule ####
Тег &lt;rule&gt; имеет две формы: краткую (для описания валидации с участием одного поля) и полную (для описания валидации с участием более одного поля, когда валидирующее правило проверяет несколько полей сразу).

##### Краткая форма тега rule #####
Имеет следующие **обязательные** атрибуты:

* **for** — имя поля формы, к которому применяется правило.
* **type** — имя (алиас) валидирующего правила.

**Опциональные** атрибуты, общие для всех тегов &lt;rule&gt;:

* **item** — обозначает номер элемента в массиве элементов формы с одинаковым именем. Как известно, веб-формы могут иметь более одного элемента с уникальным именем, и SVARX позволяет указывать отдельные правила для каждого из таких элементов. Нумерация с нуля.
* **onerror** — идентификатор ошибки, которая будет вызвана в случае нарушения правила. Может состоять из латинских букв, подчёркиваний и тире.
* **errtarget** — имя поля формы, на котором реально будет вызван обработчик SVARX-ошибки для данного правила. По умолчанию, это событие выполняется на поле, указанном внутри атрибута for, но данный атрибут позволяет переопределить это поведение. Если атрибут наличествует, но содержит пустую строку, обработчик вызовется на самой форме. Этот атрибут используется для семантческого соотнесения ошибки с другим элементом, нежели тот, на кототом определёно правило валидации.
* **errtargetitem** — аналог атрибута **item**, но относится к **errtarget**. Для случая, когда указан **errtarget** и в форме есть несколько элементов с подобным именем, использование **errtargetitem** позволяет указать номер элемента. Нумерация с нуля.
* **inverted="yes|no"** — логическое **not** для правила, меняющее результат проверки на противоположный

Прочие атрибуты тега &lt;rule&gt; зависят от указанного типа проверки.

##### Полная форма тега rule #####
Тег &lt;rule> в полной форме является контейнером, у которого могут быть вложенные элементы.
Атрибуты **for**, **item**, **errtarget**, **errtargetitem** в полной форме записи не используются, вместо них в контейнер тега &lt;rule&gt; добавляются вложенные теги:

* &lt;el /&gt; — аналог атрибута **for** из краткой формы, используется для указания элемента, с которым связано правило
* &lt;errtarget /&gt; — аналог атрибута **errtarget**

Теги &lt;el&gt; и &lt;errtarget&gt; имеют обязательный атрибут **name** для указания имени элемента формы, и опциональный атрибут **item** (аналог атрибутов **item** и **errtargetitem** из краткой формы записи). Семантика остаётся та же самая, но для правил, проверяющих более одного поля (например, проверка равенства двух полей), можно перечислить все эти поля, чего нельзя сделать в краткой записи. Теоретически, можно всегда пользоваться полной формой, но результирующий XML получится более объёмным.
Прочие атрибуты тега &lt;rule&gt; в полной форме, как и в краткой, зависят от указанного типа проверки.

По умолчанию все правила в блоке &lt;validate&gt; связаны логикой AND, т.е. форма считается безошибочной, если ни одно правило не вызвало ошибки.

Правила &lt;rule&gt; можно объединять в семантические блок &lt;block&gt;. У &lt;block&gt; нет обязательных атрибутов, но есть опциональные:

* **logic="and|or|if"** — логика объединения вложенных правил <rule> (по умолчанию — and). Значение **if** имеет особую семантику, о ней ниже.
* **onerror**  — идентификатор ошибки, которая будет вызвана в случае, если проверка блока провалилась.
* **errtarget**, **errtargetitem** — см. выше. Этот атрибут особенно полезен именно для &lt;block&gt;, т.к. он семантически не привязан ни к одному полю формы, а это не всегда хорошо.
* **inverted="yes|no"**  — аналогично <rule>, но меняет логическое значение результата блока целиком 

У тега &lt;block&gt;, так же как и у тега &lt;rule&gt;, есть полная форма записи (выше описана именно краткая). Полная форма отличается тем, что запрещает использование атрибутов **errtarget** B **errtargetitem**, но разрешает использование вложенных тегов &lt;errtarget&gt;, аналогично полной форме записи тега &lt;rule&gt;.

Блоки можно неограниченно вкладывать друг в друга.

Блок с logic="if" ведёт себя особым образом: он эмулирует поведение стандартного "if..then..else". У такого блока должно быть не менее двух потомков (ими могут быть другие &lt;block&gt; или &lt;rule&gt;). Первый считается условием (аналог IF), второй блок (аналог THEN) вступает в силу (т.е. учитывается при валидации) только тогда, когда первый блок при проверке истинен. Опциональный третий блок (аналог ELSE) вступает в силу тогда, когда первый блок даёт при проверке ложный результат.

Пример:

```xml
<block logic="if">
    <!--  Если поле login не является адресом e-mail, то... -->
    <rule for="login" type="email" inverted="yes" />
    <!--  ...считать ошибкой, если оно начинается с цифры: -->
    <rule for="login" type="regexp" partmatch="^\d" inverted="yes" onerror="login_start_digit" />
</block>
```

Атрибуты onerror на первом элементе условного блока (аналоге IF) и на самом &lt;block logic=&quot;if&quot;&gt; ведут себя не так, как (вероятно) ожидает пользователь, поэтому на этих блоках указывать их не рекомендуется. Возможно, в будущем эта рекомендация станет правилом. Чтобы обработать результат проверки условного блока, используйте обработчики onerror на блоках THEN или ELSE.

#### Блок preprocess ####
В этом блоке перечисляются правила предварительной обработки значений полей. Каждое правило имеет синтаксис, аналогичный синтаксису тегов &lt;rule&gt;, но при этом не рассматриваются атрибуты **errtarget** и **errtargetitem**.


```xml
<rule
    for="имя поля"
    type="тип препроцессинга"
/>

```
Объединение правил в блоки не используется, но можно задавать несколько полей с использованием расширенного синтаксиса тега &lt;rule&gt; (см. соответствующий раздел).

Препроцессинг выполняется с соблюдением указанного порядка полей и обработок.
Неизвестные типы обработок игнорируются.

Препроцессинг **не выполняется**:

* **Для любых не-текстовых контролов** (т.е. чекбоксы, радиобаттоны, селекты не обрабатываются)
* Для полей типа "file" (попытка изменения значений на таких полях выдаёт security error)
* Для полей, отмеченных как readonly (спорное место, реализация может измениться)

Пример:

```xml
<preprocess>
    <rule for="iname" type="trim" />
    <rule for="bday" type="parseint" />
</preprocess>

```

Внутри одного svarx-файла можно хранить несколько блоков &lt;preprocess&gt;. В этом случае нужно каждому из них указывать уникальный идентификатор через атрибут **id**.
По умолчанию будет использован первый по порядку блок, но при инцииализации jQuery-SVARX-плагина в опциях можно передать ключ **preprocessBlockId**, и в этом случае будет использован блок с соответствующим **id**.
