Ajax-валидация и SVARX.

SVARX-валидация в виде плагина для jQuery работает на основе пользовательских событий, и поэтому в основе своей синхронна: любая валидация должна дать ответ сразу, это основа API плагина.

В то же время, некоторые проверки можно делать лишь на стороне сервера через Ajax-запросы. Как научиться использовать такие проверки в SVARX?

Допустим, мы проверяем в форме поле **address**. Для начала, давайте напишем в SVARX-файле пользовательское правило:


<rule
    for="address"
    type="my:ajax"
    onerror="address_fail" />
    
Теперь надо написать JavaScript-функцию, которая реализует проверку "my:ajax". Согласно API, эта функция должна сразу вернуть значение true или false. Если пользователь обязан дождаться результата проверки и без этого отправлять форму нельзя, пусть значением по умолчанию будет false. Если проверка необязательная — по умолчанию возвращайте true.
А как же быть с самой ajax-проверкой? Мы вызовем её (асинхронно) и сохраним результат в кеше. Если при повторном вызове валидации результат асинхронной проверки для текущего значения поля **address** известен, вернём его, а иначе — значение по умолчанию.

Я имею в виду что-то вроде этого:

(function() {
    var cache = {};
    $.fn.svarx.rules['my:ajax'] = function(elems, rule) {
        var elem = elems[0],
            val = elem.value,
            defaultResult = false;
        
        if (val in cache) {
            return cache[val];
        } else {
            $.ajax({
            	/* ...много параметров для работы с ajax... */
            	   
            	success: function(data) {
            	    // кладём результат проверки в кэш.
            	    // ключом является значение, для которого делалась проверка
            	    cache[val] = data.result;
            	}
            });
            
            return defaultResult;
        }
    };
})();

Теперь валидация будет проваливаться снова и снова, пока асинхронная проверка не вернёт истинное значение.

Мы сделали самую важную часть работы — изобрели принцип, а точнее — паттерн для реализации асинхронных проверок в SVARX.

Но у нашего примера много недостатков.

Во-первых, мы ожидаем, что пользователь будет снова и снова пытаться отправлять форму, пока не дождётся ответа асинхронной проверки. Во-вторых, даже при 100% правильном заполнении мы как минимум 1 раз покажем ошибку, т.к. первая валидация (которая отправит асинхронный запрос) гарантированно провалится. В-третьих, повторную отправку формы тоже придётся выполнять самому пользователю.

Применим хитрость и знание API плагина SVARX.

1). Вообще запретим отправку формы через submit. Отправку будем делать из обработчика события 'aftersvarx', т.к. в него приходит результат проверки.

$('form')
    .bind('submit', function() {
        return false;
    })
    .bind('aftersvarx', function(e, result) {
        if (result) this.submit();  // не вызывает события 'submit'
    });

2). Назначим SVARX-валидацию на пользовательское событие 'validate':
$('form')
    .svarx({
        svarxURL: '/svarx/form1.xml',
        bindTo: 'validate'
    });

3). Научим асинхронную проверку запускать валидацию повторно, если результат положительный:

(function() {
    var cache = {};
    $.fn.svarx.rules['my:ajax'] = function(elems, rule) {
        var elem = elems[0],
            val = elem.value,
            defaultResult = false;
        
        if (val in cache) {
            return cache[val];
        } else {
            $.ajax({
            	/* ...много параметров для работы с ajax... */
            	   
            	success: function(data) {
            	    // кладём результат проверки в кэш.
            	    // ключом является значение, для которого делалась проверка
            	    cache[val] = data.result;
            	    
            	    // запускаем валидацию повторно
            	    if (data.result && elem.value === val) {
            	        $(elem.form).trigger('validate');
            	    }
            	}
            });
            
            return defaultResult;
        }
    };
})();

Чего мы добились?

Теперь при попытке отправить форму submit не происходит, но срабатывает валидация. Она приводит к ошибке, но при этом уходит ajax-запрос на проверку и через некоторое время возвращается ответ. В случае, если проверка успешна, заново инициируется валидация, уже искусственно, и если всё остальное хорошо — форма отправляется. Мы добились нужного нам поведения.
