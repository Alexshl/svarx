### События, которые генерирует jQuery-плагин ###

Многое в jQuery-реализации SVARX реализовано с помощью пользовательских событий. Через эти события можно гибко управлять основными этапами SVARX-валидации.

Все события, если явно не указано иное, следует слушать и вызывать на DOM-элементе валидируемой формы (form). Разумеется, возможен вызов и на дочерних элементах, т.к. все пользовательские события в jQuery всплывают (bubble).

#### beforesvarx ####

Вызывается непосредственно перед тем, как начнётся SVARX-валидация.
Обработчик получает вторым аргументом (после самого объекта события) имя события, которое инциировало валидацию.
Например, в случае, если валидация инициирована по submit, то в функцию-обработчик придут значения:

```javascript
$('form').bind('beforesvarx', function(e, eventType) {
    alert(eventType);  // 'submit'
});
```
Если вызвать `e.preventDefault()` на событии **beforesvarx**, то валидация не будет выполнена (не будет начата).

#### svarxerror ####

Вызывается каждый раз, когда случается ошибка валидации. В отличие от прочих событий, вызывается на элементе-виновнике (или на элементах, которые обозначены как errtarget для нарушенного правила).
Оно редко используется напрямую, но через него вызывается функция **error** из API плагинов визуализации.

В качестве аргументов обработчику на вход приходит (кроме объекта события) идентификатор `onerror` от правила, которое провалилось при проверке.

#### aftersvarx ####

Вызывается сразу после того, как отработала проверка всех правил и известен результат валидации.
Кроме объекта события, обработчик получает на вход результат валидации (boolean: true, если ошибок нет, и false, если есть хотя бы 1 ошибка) и тип события, вызвавшего валидацию.
Например, если валидация случилась по событию submit, третьим аргументом придёт строка 'submit'.

Если вызвать `e.preventDefault()` на событии **aftersvarx** (первый аргумент обработчика), то будет предотвращено также и выполнение события, инициировавшего валидацию. Пример:

```javascript
$('form').bind('aftersvarx', function(e, validationSuccessful, initialEventType) {
    if (initialEventType == 'submit'  // если валидация случилась по событию submit...
        && !validationSuccessful  // ...и нашла ошибки, то...
       ) {
    	// ..предотвращаем отправку формы
    	e.preventDefault();
    	//
    	// Обратите внимание: мы предотвращаем текущее событие (aftersvarx),
    	// а в итоге предотвращается совсем другое событие (initialEventType).
    	// Эта функциональность реализуется внутри svarx-плагина, пользователю для этого
    	// ничего не нужно делать.
    }
});
```
Почему нельзя автоматически предотвращать через `preventDefault()` любое событие, инициирующее валидацию, в случае, если валидация провалилась? Потому что при использовании валидации по таким событиям, как **keyup** или **click**, вам может не понравиться результат.

В API плагинов визуализации есть метод **after**, который тоже вызывается по событию **aftersvarx**.
Если вам нужно предотвращать отправку формы при ошибках валидации, это удобнее сделать именно в методе **after** (проверить результат валидации, тип инициировавшего события, вызывать e.preventDefault() на текущем событии).

#### svarxformupdate ####
На это событие бессмысленно назначать собственные обработчики, но если его инициировать (trigger) на форме, произойдёт сброс всех внутренних кэшей, ускоряющих обращение SVARX-плагина к элементам формы.

Если вы используете параметр `immutable: true` при вызове метода `.svarx`, плагин кэширует обращения к элементам формы. Это сильно ускоряет работу, но даст непредсказуемые результаты, если ранее существовавшие элементы формы удалить. Кроме того, вновь добавленные элементы из-за особенностей кэширования также не будут учтены валидацией, даже если про них есть SVARX-правила. В этом случае можно использовать событие **svarxformupdate** для единовременного сброса таких кэшей.

Если ваша форма меняется часто или вы не можете точно контролировать момент, в который состав полей изменится, не используйте параметр `immutable: true`, и событие **svarxformupdate** вам тоже не понадобится.

#### svarxloaded ####

Вызывается в случае успешной загрузки XML с правилами (как синхронной, так и асинхронной).
Обработчику, кроме объекта события, передаётся на вход SVARX XML-документ (клонированный, но уже после разворачивания правил и некоторого препроцессинга, т.ч. он может отличаться от исходного документа) и ссылка на опции плагина, переданные при инициализации.

#### svarxfailed ####

Вызывается в случае, если загрузить XML с правилами по каким-либо причинам не удалось.
Обработчику на вход, кроме объекта события, передаются в указанном ниже порядке:

  * XMLHttpRequest-объект (или пустой объект в случае загрузки без Ajax);
  * текстовый статус ошибки;
  * ссылка на опции плагина, переданные при инициализации.
  


