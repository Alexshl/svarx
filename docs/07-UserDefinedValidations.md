### Пользовательские правила валидации ###
jQuery-реализация позволяет на основе стандартного API создавать и подключать пользовательские типы проверок и препроцессинга.
Кастомные методы препроцессинга добавляются по сходному API.

Действует соглашение, согласно которому имена пользовательских проверок и препроцессингов должны начинаться с «неймспейса» и содержать внутри двоеточие, напр. **ya:external_email**. В дальнейшем это соглашение может исчезнуть или, напротив, стать обязательным.

В SVARX-файле пользовательские проверки используются так же, как и обычные встроенные, в атрибутах type тегов &lt;rule&gt;.

#### Как добавить свой тип валидации ####

К объекту **jQuery.fn.svarx.rules** следует добавить новое свойство, которое ссылается на пользовательскую функцию валидации.
Имя свойства и будет названием нового типа проверки.
Имя свойства должно включать в себя «неймспейс» через двоеточие, например **ya:phone** — это позволит отличать пользовательские проверки от встроенных.
Такие правила легко переносить из проекта в проект, т.к. наличие пространства имён почти гарантирует уникальность названия пользовательской проверки.
        
Рассмотрим создание нового правила **ya:svoy**, проверяющего факт наличия подстроки **&quot;yandex&quot;** в пользовательском вводе.
Это учебный пример, в реальной жизни лучше использовать встроенное правило regexp.
        
Начнём с заготовки-пустышки.
Любая функция проверки по умолчанию (а также в случае нехватки данных или непредвиденных ошибок) должна возвращать **true**.
        
```javascript
(function($) {
    $.fn.svarx.rules['ya:svoy'] = function(els, rule) {
        return true;
    };
})(jQuery);

```

На вход фция проверки получает два аргумента:

  * массив (именно массив, не NodeList) из DOM-элементов, на которых должна пройти валидация
  * ссылку на XML-узел с валидационным правилом из SVARX-файла

Ядро плагина гарантирует, что массив els не пуст, и что все элементы els:

  * существуют
  * являются элементами нужной веб-формы
  * представляют из себя input, select или textarea
  * у них не включен атрибут disabled
  * их значения не пусты (проверяется только для текстовых контролов)

Также ядро плагина самостоятельно обрабатывает атрибут **inverted**, функция проверки не должна его учитывать.
Почему передаётся массив? Дело в том, что некоторые правила могут принимать два и более поля сразу (или даже произвольное число полей, как встроенное правило **eq**).
Ядро SVARX-плагина не знает, сколько именно элементов требуется правилу, и поэтому подаёт их все списком, а задача правила — разобраться с этими данными самостоятельно.

Т.к. наше правило берёт на вход одно поле, мы будем брать первый элемент:

```javascript
(function($) {
    $.fn.svarx.rules['ya:svoy'] = function(els, rule) {
        var check = true,  // по умолчанию проверка всегда истинна
            el = els[0];
            
        if (!/yandex/i.test(el.value)) {  // проверяем, не нарушено ли правило...
            check = false;  // правило нарушено! ставим флажок в false
        }
        
        // возвращаем финальный результат
        return check;
    };
})(jQuery);

```

Допустим, наше правило допускает кастомизацию, которая запрещает игнорировать регистр символов при проверке.
Тогда мы можем отметить это дополнительным (произвольным) атрибутом на соответствующем теге &lt;rule&gt;, например:

```xml
<rule for="name email" type="ya:svoy" forcecase="yes" />

```

Тогда внутри нашей проверки нам надо будет обращаться к атрибуту **forcecase** SVARX-правила:


```javascript
(function($) {
    $.fn.svarx.rules['ya:svoy'] = function(els, rule) {
        var check = true,  // по умолчанию проверка всегда истинна
            el = els[0],
            // Проверяем, можно ли нам игнорировать регистр символов при проверке
            re = new RegExp('yandex', $(rule).attr('forcecase') == 'yes' ? '' : 'i');

        if (!re.test(el.value)) {  // проверяем, не нарушено ли правило...
            // правило нарушено! ставим флажок в false
            check = false;
        }
        
        // возвращаем финальный результат
        return check;
    };
})(jQuery);

```

Получившееся кастомное валидирующее правило нужно подключить к странице после основного плагина, но до первого вызова SVARX-проверки.
